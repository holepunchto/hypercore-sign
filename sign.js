#!/usr/bin/env node

const path = require('path')
const fsProm = require('fs/promises')
const os = require('os')
const sodium = require('sodium-native')
const idEncoding = require('hypercore-id-encoding')

const homeDir = os.homedir()
const secretKeyLoc = path.join(
  homeDir, '.hypercore-sign', 'private-key'
)
const publicKeyLoc = path.join(
  homeDir, '.hypercore-sign', 'public-key'
)

async function main () {
  const key = process.argv[2]
  const length = process.argv[3]
  const treeHash = process.argv[4]
  if (!key || !length || !treeHash) {
    console.log('Sign a message. Call as:\nhypercore-sign key length treeHash\nNote: requires a public and private key, generated by hypercore-sign-generate-keys')
    process.exit(1)
  }

  if (!idEncoding.isValid(key)) throw new Error('Invalid key')
  if (!idEncoding.isValid(treeHash)) throw new Error('Invalid tree hash')

  const secretKey = Buffer.from(
    await fsProm.readFile(secretKeyLoc, 'utf-8'),
    'hex'
  )
  const publicKey = Buffer.from(
    await fsProm.readFile(publicKeyLoc, 'utf-8'),
    'hex'
  )

  let msg = `hypercore ${key}\n`
  msg += `length ${length}\n`
  msg += `treeHash ${treeHash}`
  const signedMsg = Buffer.alloc(msg.length + sodium.crypto_sign_BYTES)

  console.log(`\nSigning message:\n${msg}`)
  sodium.crypto_sign(signedMsg, Buffer.from(msg), secretKey)
  console.log(`\nSigned message:\n${signedMsg.toString('hex')}`)

  console.log(`\nVerifiable with pub key: ${publicKey.toString('hex')}`)
  console.log('\nFull command to verify:')
  console.log(`hypercore-verify ${signedMsg.toString('hex')} ${publicKey.toString('hex')}`)
}

main()
